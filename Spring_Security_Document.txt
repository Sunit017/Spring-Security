 
Authentication --
================
Authentication means is knowing about the identity of user who is using the application .

Authorization ---
================
it is next to authenication , giving authority to user use the specific components of application 

Spring Security ----
========================
Spring Security is a powerful authentication and authorization framework for Java applications. It intercepts requests before they reach your controller and checks 
if the user is authenticated and authorized.

ðŸ”¹ How It Works (High-Level Flow):
1. Incoming HTTP request
2. Passes through Security Filter Chain
3. Filters like UsernamePasswordAuthenticationFilter or JwtAuthenticationFilter validate the request
4. If valid â†’ creates a SecurityContext (stores user info)
5. Controller is accessed
6. If invalid â†’ returns 401 Unauthorized



Security Fillter chain before that delegating fillter chain 

Fillter = before request go to controller and after response come from controller fillter stands in between 

authentication fillter -- if you added spring security it will come and job is to intercept authenication request and grab username and password and create 
authenication object /once object is created , object will hand over to authentication manager 

authenication manager -- it decide what to do with this credential , delicate task authenicate to user to someone else and i need authentication provider
|> authenticate()

authentication provider (DaoauthenticationProvider)-- check that given credential right or wrong , it need 2 things 1.passwordEncoder 2.userDetailsService 
|>matches

passwordEncoder -- when ever user credential pass in always encoded some form of encryption and to decript the password you need to do processing and here passwordEncoder help
|>loadByUsername()

userDetailsService -- load the user Details it will load the data to system what ever it has and from database // if don't want go with single user , go with multiple
user 

security context - it is context which availabe through out the request ,

you can configure customer username and password instead of using default / or copying automated generated password

-------------------
SPRING SECURITY 3.0	
--------------------
In SpringBoot3 the WebSecurityConfigureAdaptor has been depricated which was provided us Authentication and Authrization by override constructor
Here we need to create bean of userDetailsService  to define the authenicated related stuff .
And for authorization we have to create bean of springSecurityFillterChain // by using this we can permit and authenicate api endpoint 
** Password Encoder - Encrypt the password / create bean of PasswordEncoder / before storing into db .

Q- I don't want to hardcode this username and password , so what to do?
ans - 1. first create the entity to store the username and password related stuff
      2. create your own userdetailsservice and it implements userDetailsService
      3. Override the method inside it , that is - loadUserByUsername and inject the repo 
      4.create findByName method in repo and use it inside the loadUserByUsername method , but method wants return type is userdetails object 
      5. need to convert the userinfo object into userdetails object for that need to create another userdetails class (userinfodetails extends userdetails) override 
       all the method 
     6. we need authentication provider who will talk with userDetailsService 	   


Basic VS Form base Authentication ===============
---------------------------------------------------
1.>Basic Authentication when you hit the endpoint you will see and popup in browser for login and there no url for login and logout
   Form base Authentication when hit the endpoint first a login form will come and when you want to logout then you have to hit logout url 

2.> In basic authentication if you want to logout if have to close the session 	/ JsessionId cookies will create and cookies will manage the session  and 
      authorization header over here 
   In Form base authentication you have the request and response cookies and also payload tab is also there 	  
   
-> As cookies maintain in basic authenication that is we can say it as statefull , and we can make it stateless
 http.sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
				
Base64 = username:password

ROLE BASED ACCESS ------
=================================
@PreAuthorize("hasRole('USER')")- by annotating this you are telling to springsecurity i want only user to access paticular things 
,used to check authorization before checking a method 
to work this we need to go spring security configuration file and annotate @EnableMethodSecurity 

noop - basically we use when we built demo applicaton - telling spring security that don't encrypt it save at is 

What is Hashing ?
Converting normal String to encrypted is called hashing 

Algorithm - bcrypt - involves using salting  - normal string (password) +salt value = more encrypted value 


WITHOUT JWT ----
========================
1 . No advance feature like no expiration time 
2. can be decode easily 
3. should go for basic "Custom Token System" 
JWT --
==============
  JWT (JSON Web Token) is commonly used for stateless authentication.
  Json Web Token , It is open and Industry Standard 
 
 Works --
 1 . User tries to login 
 2.server will generate the token 
 3. token will issue to user
 4.token sent in API requests to server
 5. server will Validate token 
 6. Request authorized if valid , else error 

How Token Sent ?
Ans - Token sent using HTTP authorization header 
format - Bearer<token> 

3 color code - RED , Purple , blue 

RED is Header , and header consist of type of token (JWT)and signing algorithm used  (chart256 or RSA )
Purple is payload , it is consist of claims and specifif information about user like userID and UserName and sort of metadata than can be added 
Blue is signature , like a secret and appended eith entire token 

File Needed--
=================
1. JwtUtils - Contains Utility methods for generating , parsing and validating JWTs.
             - Include generating token from username , validating a token and extracting username from it 

2.AuthToKen Filter - If there is request come in it goes series of filter and you need to add your own custome filter over here ,to intercept the request 
and do validation with JWTutils that we created , if request is valid we add authentication context as well 

3. AuthEntryPoint JWT - It provide custome handling form unauthorized requests 

4. Security Config - 	configure filter and rules of application  


For OAuth2.0==========
----------------------
First we need to add Oauth2 Client Dependecies 
for configuration we need clientid and client secret , configure in application.properties 


KEYCLOAK
--------

1. Introduction: What is Keycloak? 
Ans - âœ… Keycloak is an open-source Identity and Access Management (IAM) solution that provides authentication and authorization for applications.
      âœ… It supports SSO (Single Sign-On), OAuth2, OpenID Connect (OIDC), and SAML

2. Why Did You Choose Keycloak?
Ans - âœ… Centralized Authentication: All authentication is handled by Keycloak, reducing security risks.
      âœ… OAuth2 & OpenID Connect Support: Allows token-based authentication for secure API access.
      âœ… Role-Based & Attribute-Based Access Control (RBAC & ABAC): Manages roles and permissions efficiently.
      âœ… Session Management & SSO: Users log in once and access multiple applications.
      âœ… Extensibility: Custom providers, authentication flows, and policies can be implemented.
	 
3. How Did You Integrate Keycloak with Spring Boot?
Ans - Step 1: Added Keycloak Dependencies
      In pom.xml, I included the Keycloak libraries:
      Step 2: Configured Keycloak in application.yml
      I specified the Keycloak server details and realm configurations: 
	  Step 3: Configured Spring Security
      I used OAuth2 resource server for JWT authentication:
	  Step 4: Implemented Role-Based Access Control (RBAC)
      Keycloak assigns roles to users, and Spring Security verifies them.
      Fetching Roles from JWT in Spring Security:
	  
4. How Does Keycloak Handle Authentication & Authorization?
Ans - âœ… Authentication:
The frontend redirects the user to the Keycloak login page.
After successful login, Keycloak generates a JWT token.
The frontend stores the token and includes it in every API request.

    âœ… Authorization:
The backend extracts the JWT token from the request header.
Spring Security validates the token and extracts roles & permissions.
Based on roles, access is granted or denied
	  
Terms 
.Realm - isloate and manage 
Client 
Client scope - 
users - 
groups 

Features - 
 Signle sign on 
 identity brokering and social login 
 user federation 
 admin console 
 account management console 
 
 
 
Q1- How do you implement role based access control in spring Security ?
 Ans - By using Method level Security    - @PreAuthorize("hasRole('ADMIN')")
                                         public void deleteUser(Long userId) { }
      URL-Based Security in Configuration:   http
    .authorizeHttpRequests(auth -> auth
        .requestMatchers("/admin/**").hasRole("ADMIN")
        .requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
        .anyRequest().authenticated());

Q3: How do you configure security in a Spring Boot application? 
Ans - Spring Boot automatically configures security, but we override it using a SecurityFilterChain bean. 

Q4: How does JWT authentication work in Spring Security?
Ans - âœ… The server issues a JWT token after successful authentication.
      âœ… The client includes this token in the Authorization header of subsequent requests.
      âœ… The backend validates the token and extracts the user details.

Q5: How did you integrate OAuth2 with Spring Security?
Ans - Spring Security provides built-in OAuth2 support via spring-boot-starter-oauth2-client.
      We configure OAuth2 authentication using OAuth2LoginConfigurer. 
	  @Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
        .oauth2Login(Customizer.withDefaults())  // Enables OAuth2 login
        .logout(Customizer.withDefaults());
    return http.build();
}

Q6: How do you configure session management in Spring Security?
Ans - http.sessionManagement(session -> session
    .sessionCreationPolicy(SessionCreationPolicy.STATELESS));
      
	  STATELESS: No session is created (useful for JWT authentication).
      ALWAYS: Always creates a session.
      NEVER: Uses session if exists but wonâ€™t create one.

Q7: What is CSRF, and how does Spring Security handle it? 
 âœ… Cross-Site Request Forgery (CSRF) is an attack where malicious requests are sent from an authenticated userâ€™s session.
 âœ… Spring Security enables CSRF protection by default.
 
Q8: How do you handle authentication and authorization failures?
Ans - Custom Authentication Failure Handler  
      @Component
    public class CustomAuthFailureHandler extends SimpleUrlAuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)
            throws IOException {
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Authentication Failed");
    }
}

Q9: How do you prevent brute-force attacks in Spring Security?
 Ans - Use account lockout after multiple failed login attempts.
       Implement rate-limiting on authentication APIs.
       Use captcha after multiple failed attempts.